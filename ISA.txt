LI R0 0                         ; constant 0
LI R3 19                        ; constant 19

// Outer for-loop start
SUB R1 R1 R1                    ; 'x = 0'
JGT R1 R3 <end loop>            ; 'for(x from 0 to 19)'
    // Inner-loop start
    SUB R2 R2 R2                ; 'y = 0'
    JGT R2 R3 <end loop>        ; 'for(y from 0 to 19)'

    // Fetching the memory address of out_image(x,y) into R4     
        MULI R4 R2 20           ; 'addressXY_out = y*20'                -> using formula: y*n+x
        ADD R4 R4 R1            ; 'addressXY_out = adressXY_out + x'    -> using formula: y*n+x 
        ADDI R4 R4 400          ; 'addressXY_out = adressXY_out + 400'  -> The memory address of pixel (x,y)
    
    //Processing border pixel   
        JEQ R1 R0 20            ; if (x==0)
        JEQ R2 R0 20            ; if (y==0)   
        JEQ R1 R3 20            ; if (x==19) 
        JNEQ R2 R3 21           ; if (y==19) and if (y!=19) then jump     
            SD R0 R4            ; 'memory(addressXY_out) = 0  -> set value of AddressXY_out = 0'

    // Fetching the memory address of in_image(x,y) into R5     
        MULI R5 R2 20           ; 'addressXY_in = y*20'               -> using formula: y*n+x
        ADD R5 R4 R1            ; 'addressXY_in = adressXY_in + x'    -> using formula: y*n+x 
        
    // Processing inner pixel

        LD R6 R5                ;  val = memory(addressXY_in) -> Get the value of addressXY_in
        JNEQ R5 R0 24           ;  if (addressXY_in == 0)
            ADDI R4 R4 400      ; 'tempXY += 400'
            SD R0 R4            ; 'pixel_out(tempXY) = 0'
            JR **
        
                                ; Processing inner pixels
                                ; if ( in_image (x , y ) ==0 )


                                ; else 

            // if (n_image (x -1 , y ) ==0 or
                in_image ( x +1 , y ) ==0 or
                in_image (x ,y -1) ==0 or
                in_image (x , y +1) ==0)

                // (n_image (x -1 , y ) ==0) or (in_image ( x +1 , y ) ==0)
                    
                    OR R91 R92 R93 
                    JNEQ _ 
                // (in_image (x ,y -1) ==0) or (in_image (x , y +1) ==0)
    ADDI R2 R2 1    ; y++
    JR 9
    **
    // Inner for-loop end
ADDI R1 R1 1  ;  x++
JR 6
*
// Outer for-loop end

___________________________________________________________________________________________________
Instruction-Set Architecture (ISA)

Arithmetic and Logic:
// Subtraction              SUB R1 R2 R3    ;     R1 = R2 - R3 
// Multiplication           MUL R1, R2, R3  ;     R1 = R2 * R3
// Bitwise OR               OR R1 R2 R3     ;     R1 = R2 or R3 
// Immediate Add.           ADDI R1 R2 4    ;     R1 = R2 + 4
// immidiate Sub.           SUBI R1 R2 5    ;     R1 = R2 - 5
// immidiate Mul.           MULI R1 R2 6    ;     R1 = R2 * 6

Data transfer:
// Load immidiate           LI R1 6         ;     R1 = 6
// Load data                LD R1, R2       ;     R1 = memory(R2)
// Store data               SD R1, R2       ;     memory(R2) = R1 


Control and Flow:
// Jump                     JR 7            ;     goto inst. 7
// Jump if greater than     JGT R2 R3 10    ;     if(R2>R3) goto inst. 10
// Jump if not equal        JNEQ R2 R3 8    ;     if (R2 != R3) goto inst. 8



